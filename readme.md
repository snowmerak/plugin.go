# plugin.go

`plugin.go` is a Go library that facilitates communication with external plugin processes over standard I/O using a custom multiplexing protocol. It allows for loading Go plugins (or any executable that adheres to the communication protocol) and calling functions within them.

This library provides:
- A `Loader` to manage the lifecycle of a plugin process.
- A `Module` for the plugin side to register handlers.
- Generic `Adapter`s for typed communication using JSON or Protocol Buffers.

## Features

- Forking and managing external processes as plugins.
- Multiplexed communication over stdin/stdout.
- Request/Response pattern with sequence IDs.
- Generic adapters for JSON and Protobuf serialization.
- Typed handler registration on the plugin side for JSON and Protobuf.

## Installation

```bash
go get github.com/snowmerak/plugin.go
```

## Usage

### Client-Side (Loading and Calling a Plugin)

First, create a `Loader` for your plugin executable:

```go
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/snowmerak/plugin.go/lib/plugin"
	// Assuming you have protobuf definitions in a package like mypb
	// "path/to/your/project/mypb"
)

// Example JSON types
type MyJSONRequest struct {
	Data string `json:"data"`
}

type MyJSONResponse struct {
	Result string `json:"result"`
}

// Example Protobuf types (assuming these are generated)
// type MyProtoRequest struct { ... } // Implements proto.Message
// type MyProtoResponse struct { ... } // Implements proto.Message

func main() {
	loader := plugin.NewLoader("./path/to/plugin/executable", "myplugin", "v1.0.0")
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	if err := loader.Load(ctx); err != nil {
		log.Fatalf("Failed to load plugin: %v", err)
	}
	defer loader.Close()

	// Using JSON Adapter
	jsonAdapter := plugin.NewJSONAdapter[MyJSONRequest, MyJSONResponse](loader)
	jsonReq := MyJSONRequest{Data: "Hello JSON"}
	jsonResp, err := jsonAdapter.Call(ctx, "HandleJSON", jsonReq)
	if err != nil {
		log.Printf("JSON call error: %v", err)
	} else {
		fmt.Printf("JSON response: %+v\n", jsonResp)
	}

	// Using Protobuf Adapter
	// (Assuming MyProtoRequest and MyProtoResponse are defined and implement proto.Message)
	/*
	protoAdapter := plugin.NewProtobufAdapter[*mypb.MyProtoRequest, *mypb.MyProtoResponse](
		loader,
		func() *mypb.MyProtoResponse { return new(mypb.MyProtoResponse) }, // Factory for response type
	)
	protoReq := &mypb.MyProtoRequest{Input: "Hello Protobuf"}
	protoResp, err := protoAdapter.Call(ctx, "HandleProto", protoReq)
	if err != nil {
		log.Printf("Protobuf call error: %v", err)
	} else {
		fmt.Printf("Protobuf response: %s\n", protoResp.GetOutput())
	}
	*/
}
```

### Plugin-Side (Implementing a Plugin)

The plugin executable needs to create a `Module` and register handlers.

```go
package main

import (
	"context"
	"fmt"
	"log"
	"os" // For os.Stdin, os.Stdout

	"github.com/snowmerak/plugin.go/lib/plugin"
	// Assuming you have protobuf definitions in a package like mypb
	// "path/to/your/project/mypb" 
	// For Protobuf example, you would also need:
	// "google.golang.org/protobuf/proto" 
)

// Example JSON types (must match client)
type MyJSONRequest struct {
	Data string `json:"data"`
}

type MyJSONResponse struct {
	Result string `json:"result"`
}

// Example Protobuf types (assuming these are generated in mypb package)
/*
// In mypb/my.proto (example)
// syntax = "proto3";
// package mypb;
// option go_package = "path/to/your/project/mypb";
// message MyProtoRequest {
//   string input = 1;
// }
// message MyProtoResponse {
//   string output = 1;
// }

// In Go code (mypb/my.pb.go generated by protoc)
type MyProtoRequest struct {
	// ... generated fields ...
	Input string
}
func (m *MyProtoRequest) Reset()        { *m = MyProtoRequest{} }
func (m *MyProtoRequest) String() string { return proto.CompactTextString(m) }
func (*MyProtoRequest) ProtoMessage()    {}
// ... other proto.Message methods ...
func (m *MyProtoRequest) GetInput() string { // Example getter
	if m != nil {
		return m.Input
	}
	return ""
}


type MyProtoResponse struct {
	// ... generated fields ...
	Output string
}
func (m *MyProtoResponse) Reset()        { *m = MyProtoResponse{} }
func (m *MyProtoResponse) String() string { return proto.CompactTextString(m) }
func (*MyProtoResponse) ProtoMessage()    {}
// ... other proto.Message methods ...
func (m *MyProtoResponse) GetOutput() string { // Example getter
	if m != nil {
		return m.Output
	}
	return ""
}
*/


// JSON Handler
func handleJSONRequest(req MyJSONRequest) (MyJSONResponse, bool) {
	fmt.Fprintf(os.Stderr, "Plugin: Received JSON request: %+v\n", req)
	if req.Data == "error" {
		return MyJSONResponse{Result: "Simulated JSON error"}, true // true for application error
	}
	return MyJSONResponse{Result: "Processed: " + req.Data}, false // false for success
}

// Protobuf Handler
/*
func handleProtoRequest(req *mypb.MyProtoRequest) (*mypb.MyProtoResponse, bool) {
	fmt.Fprintf(os.Stderr, "Plugin: Received Proto request: %s\n", req.GetInput())
	if req.GetInput() == "error" {
		return &mypb.MyProtoResponse{Output: "Simulated Protobuf error"}, true
	}
	return &mypb.MyProtoResponse{Output: "Plugin says: " + req.GetInput()}, false
}
*/

func main() {
	// Use os.Stdin and os.Stdout for communication with the host application
	module := plugin.New(os.Stdin, os.Stdout)

	// Register JSON Handler
	// The generic RegisterJSONHandler will infer Req and Resp types from handleJSONRequest.
	plugin.RegisterJSONHandler(module, "HandleJSON", handleJSONRequest)

	// Register Protobuf Handler
	/*
	// The generic RegisterProtobufHandler requires a factory for the request type.
	// Req type is *mypb.MyProtoRequest, Resp type is *mypb.MyProtoResponse.
	plugin.RegisterProtobufHandler(
		module,
		"HandleProto",
		func() *mypb.MyProtoRequest { return new(mypb.MyProtoRequest) }, // Factory for request type
		handleProtoRequest,
	)
	*/

	fmt.Fprintln(os.Stderr, "Plugin started and listening for requests...")
	if err := module.Listen(context.Background()); err != nil {
		log.Fatalf("Plugin listener error: %v", err)
	}
	fmt.Fprintln(os.Stderr, "Plugin listener stopped.")
}

## Protocol

The communication protocol uses a simple header format for messages:
- 1 byte: Message Type (Start, Data, End, Abort, Error)
- 4 bytes: Frame ID (uint32, BigEndian)
- 4 bytes: Data Length (uint32, BigEndian, for Data messages)

Data is chunked to manage large payloads.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
